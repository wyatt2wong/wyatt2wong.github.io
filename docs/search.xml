<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主机远控：内网穿透、开机</title>
      <link href="/2025/09/02/host-remote-control/"/>
      <url>/2025/09/02/host-remote-control/</url>
      
        <content type="html"><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>远控首要解决网络连接</p><h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><ol><li>独立IP： 常见机房、云服务器、企业宽带</li><li>动态DNS：常见特定家用宽带套餐或特别申请</li><li>内网穿透：常见大部分家用宽带套餐，尤其中低端套餐</li></ol><h2 id="内网穿透方案"><a href="#内网穿透方案" class="headerlink" title="内网穿透方案"></a>内网穿透方案</h2><ol><li>企业：花生壳、ZeroNews，兼顾合规性与性能。</li><li>开发：FRP 适合自建高定制化服务，ngrok 适合快速测试。</li><li>家庭：节点小宝或花生壳盒子提供极简体验。</li><li>复杂：FRP 的 P2P 模式更具优势。</li></ol><p>除了花生壳、ZeroNews、Ngrok、节点小宝等厂商的免费套餐，还有一些配额更高的免费套餐方案：</p><ol><li>ngrok：Sunny-Ngrok</li><li>FRP：Sakura Frp</li></ol><p>此外像 TeamViewer、AnyDesk 等远程桌面软件也支持内网穿透，但通常要付费，就不展开介绍。</p><h1 id="远程开机"><a href="#远程开机" class="headerlink" title="远程开机"></a>远程开机</h1><h2 id="常见方案-1"><a href="#常见方案-1" class="headerlink" title="常见方案"></a>常见方案</h2><ol><li>PCIE唤醒：<ul><li>开机卡： POWER SW和主板电源跳线接到开机卡，配置BIOS开启PCIE唤醒。<ul><li>成本：10元起&#x2F;个，仅适用台式机，且预留PCIE插槽</li><li>适用：少量主机</li></ul></li><li>网卡唤醒：配置BIOS开启Wake ON LAN(WOL)或Power On By PCI-E&#x2F;PCI，局域网有一台主机(如开机盒子&#x2F;软路由等)处于可远控状态（如运行中+内外穿透）<ul><li>成本：局域网主机价格，若路由(或家庭中控)带网络唤醒+(独立IP，或路由器&#x2F;家庭中控远控)，则无额外费用</li><li>适用：较多主机（推荐），如机房服务器</li></ul></li></ul></li><li>来电开机：<ul><li>智能插座：可统计电量（含计量功能一般价格贵点）<ul><li>成本：20元起&#x2F;个，分蓝牙Mesh&#x2F;Wifi版</li><li>适用：少量主机（推荐），如家用主机、自用办公主机</li></ul></li></ul></li></ol><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><blockquote><p>少量主机用<code>智能插座</code>，较多主机用<code>网卡唤醒(WOL)</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>号段ID与业务全局ID</title>
      <link href="/2025/08/09/segment-shard-id/"/>
      <url>/2025/08/09/segment-shard-id/</url>
      
        <content type="html"><![CDATA[<h1 id="号段"><a href="#号段" class="headerlink" title="号段"></a>号段</h1><blockquote><p>顾名思义，通过存储（如rdms、kv-store等）最大ID，由节点向存储申请一段连续号段到本地分配，来满足分布式系统对高吞吐生成全局唯一ID的需求。</p></blockquote><h3 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h3><blockquote><p>预加载</p><ul><li>加载号段长度：MAX(步长下限,MIN(步长上限, 消耗（上次步长&#x2F;耗时）平均QPS * 希望缓冲时长(秒)))</li><li>双号段：正式+预备，正式号段分配率≥阈值，且预备号段未初始，则线程cas竞争预加载号段（双重检测）</li></ul></blockquote><blockquote><p>全局缓冲</p><ul><li>Redis：双写Redis+DB(先Redis申请，无可分配号段则到DB申请号段并回写Redis)，核心使用<code>INCRBY</code>命令</li><li>容灾<ul><li>DB短暂故障：节点向DB申请号段捕获一定量异常后，短期不再请求DB，由Redis自动扩充号段（version+1)，超期后节点尝试请求Redis，DB恢复后校验version+maxId同步Redis号段</li><li>Redis短暂故障：请求&gt;达到异常阈值&gt;周期不请求&gt;重试请求&gt;捕获,以此循环</li></ul></li></ul></blockquote><blockquote><p>多计数器： 每1-N个一致性哈希虚拟节点用一个号段计数器，减少cas竞争率</p></blockquote><hr><h1 id="业务全局ID"><a href="#业务全局ID" class="headerlink" title="业务全局ID"></a>业务全局ID</h1><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>生成速率 ≥ 百万ID&#x2F;s</li><li>无时间回拨风险</li><li>弹性扩缩容</li><li>拆合冷热分片</li><li>同所属业务ID（如C端用户）数据(如订单)在同分片</li><li>迁移数据量低，且不中断服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul><li>一致性哈希算法：混合xxhash64+murmurhash64</li><li>哈希环：每个虚拟节点对应一个物理分片(一般N:1)，按负载&#x2F;数据均匀情况映射不同虚拟节点到物理节点</li><li>ID结构：<blockquote><h3 id="64位8字节-万亿级"><a href="#64位8字节-万亿级" class="headerlink" title="64位8字节(万亿级)"></a>64位8字节(万亿级)</h3></blockquote></li></ul><blockquote><ul><li>1位：0(正数)</li><li>14-16位分片基因：8,192-65,536个虚拟节点</li><li>5-7位加密版本：32-128个，金融或军事级建议≥128个加密版本(如季度换密钥，32个版本能用8年，数据归档后可复用低版本号)</li><li>42位号段ID：约43,980亿</li></ul></blockquote><blockquote><h3 id="128位16字节"><a href="#128位16字节" class="headerlink" title="128位16字节"></a>128位16字节</h3><ul><li>1位：0(正数)</li><li>23位分片基因：8,388,608个虚拟节点</li><li>20位加密版本：每天换密钥，能用3,000年</li><li>84位号段ID：正常用不完…<blockquote><p>分片粒度更细，可细粒度的映射冷热虚拟节点到对应物理节点，更少的数据迁移解决数据倾斜问题</p></blockquote></li></ul></blockquote><h3 id="生成逻辑"><a href="#生成逻辑" class="headerlink" title="生成逻辑"></a>生成逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">shardGene</span> <span class="operator">=</span> (xxhash64(所属业务ID) ^ murmurhash64(所属业务ID)) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">orderNo</span> <span class="operator">=</span> shardGene &lt;&lt; <span class="number">48</span> | (segment.generate(<span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFF</span>);</span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Short, Shard&gt; shardMap = 配置中心热加载;</span><br><span class="line"><span class="type">short</span> <span class="variable">shardGene</span> <span class="operator">=</span> (req.getOrderNo() &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="type">Shard</span> <span class="variable">shard</span> <span class="operator">=</span> shardMap.ceilingEntry(shardGene); <span class="comment">// 查找分片</span></span><br></pre></td></tr></table></figure><h3 id="拆合冷热分片"><a href="#拆合冷热分片" class="headerlink" title="拆合冷热分片"></a>拆合冷热分片</h3><ul><li>路由表变更<ul><li>新旧物理分片按映射的虚拟节点，更新到路由表</li></ul></li><li>数据迁移<ul><li>迁移：全量+增量同步源分片数据到目标分片</li><li>切流：将源虚拟节点的流量，按比例(如模序号)滚动(如每次5%+1分钟监控)切到目标分片<ul><li>回退：实现数据双向同步，通过cas(version)控制并发更新</li></ul></li></ul></li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li>ID有序性<ul><li>加密算法<ul><li>ChaCha20：低15位加密，分片基因(16位)</li><li>AES CTR：</li></ul></li><li>请求时，根据特定位标识，恢复位的位置</li></ul></li></ul><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><ul><li>号段ID溢出：ID长度增加到128位（16字节），路由时判断ID字节长度选择不同位移方式</li></ul><h3 id="demo-ddl"><a href="#demo-ddl" class="headerlink" title="demo ddl"></a>demo ddl</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `test_order` (</span><br><span class="line">`order_id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;订单id, ((xxhash(buyer_uid)^murmurhash(buyer_uid))&amp;0xFFFF)&lt;&lt;48|(号段ID&amp;0xFFFFFFFFFFFF)&#x27;</span>,</span><br><span class="line">`order_no` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;混淆的订单id，可选&#x27;</span>,</span><br><span class="line">`buyer_uid` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;买家uid&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY KEY</span> (`order_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">INDEX `order_no` (`order_no`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">INDEX `buyer_uid` (`buyer_uid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">COLLATE</span><span class="operator">=</span><span class="string">&#x27;utf8mb4_bin&#x27;</span> ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><blockquote><p>每个虚拟节点的订单号是趋势递增的，一段周期后mysql页分裂会趋于稳定</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>请求合并案例</title>
      <link href="/2025/07/17/merge-request/"/>
      <url>/2025/07/17/merge-request/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><blockquote><p>提升高频随机请求的吞吐量，减轻被依赖方(如db、下游微服务等)压力，且不产生数据一致性问题</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>按<code>请求特征+时间桶+请求数上限</code>归类，同类请求合并为一个批处理执行，执行完逐一告知各请求结果</p></blockquote><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><blockquote><ol><li>充分利用特定场景的特性：批量吞吐量 &gt; 随机请求吞吐量，减少额外开销<br><code>如：mysql insert-values 批量插入、同分片批量读写等</code></li><li>不侵入调用方</li></ol></blockquote><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><blockquote><ol><li>线程上下文无法有效传递，导致部分功能无法生效，如本地事务、调用链等</li><li>单次请求耗时有所增加：时间桶+批处理执行耗时</li></ol></blockquote><h1 id="假代码"><a href="#假代码" class="headerlink" title="假代码"></a>假代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;请求特征&quot;</span>;</span><br><span class="line"><span class="comment">// map+多产单消定量队列</span></span><br><span class="line"><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Object, MpscArrayQueue&gt;();</span><br><span class="line">Queue queue;</span><br><span class="line"><span class="type">int</span> afterMargin; <span class="comment">// 加入后队列剩余容量</span></span><br><span class="line"><span class="type">var</span> <span class="variable">future</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>(); <span class="comment">// 本次调用返回的future</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((queue=map.get(key)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">MpscArrayQueue</span>(队列容量);</span><br><span class="line">        <span class="type">Queue</span> <span class="variable">oldQueue</span> <span class="operator">=</span> map.putIfAbsent(key, queue); <span class="comment">// cas</span></span><br><span class="line">        <span class="keyword">if</span>(oldQueue !=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue = oldQueue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((idx=queue.offer(请求入参+future)) &gt; <span class="number">0</span>) &#123; <span class="comment">// cas</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 加入队列，跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    map.remove(key, queue); <span class="comment">// cas，将老队列从请求特征集合中移除，重新初始化</span></span><br><span class="line">    Thread.onSpinWait(); <span class="comment">// 自旋等待时，提示处理器优化，但线程状态不切换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(afterMargin == 队列容量-<span class="number">1</span>) &#123; <span class="comment">// 首个放入队列</span></span><br><span class="line">    创建延时任务(时间桶刻度) &#123;</span><br><span class="line">        <span class="keyword">if</span>(禁止队列生产 == <span class="literal">false</span>) &#123; <span class="comment">// cas</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(key, queue); <span class="comment">// cas删掉，重新初始化</span></span><br><span class="line">        遍历队列; <span class="comment">// MpscArrayQueue#offer()不提供返回余量，自行实现则要自旋遍历加入队列的数量</span></span><br><span class="line">        执行批处理逻辑;</span><br><span class="line">        结果逐一返回给对应future; <span class="comment">// 返回结果也是一个cas</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(afterMargin == <span class="number">0</span> &amp;&amp; 禁止队列生产 == <span class="literal">true</span>) &#123; <span class="comment">// 最后放入队列，且禁止成功(cas)</span></span><br><span class="line">    map.remove(key, queue); <span class="comment">// cas删掉，重新初始化</span></span><br><span class="line">    尝试取消延时任务 <span class="comment">// cas</span></span><br><span class="line">    遍历队列; <span class="comment">// MpscArrayQueue#offer()不提供返回余量，自行实现则要自旋遍历加入队列的数量</span></span><br><span class="line">    执行批处理逻辑;</span><br><span class="line">    结果逐一返回给对应future;  <span class="comment">// 返回结果也是一个cas</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> future;</span><br></pre></td></tr></table></figure><blockquote><p>上述假代码的线程安全，由7个cas+1个自旋解决：  </p><ul><li>cas1: 将<code>队列</code> 初始化放到 <code>请求特征集合</code></li><li>cas2: <code>请求参数</code>加入 <code>队列</code></li><li>cas3: 加入<code>队列</code>失败(满&#x2F;禁止生产)，将<code>队列</code>从<code>请求特征集合</code>中移除</li><li>cas4: 禁止队列生产</li><li>cas5: 禁止队列生产后，将<code>队列</code>从<code>请求特征集合</code>中移除</li><li>cas6: 尝试取消延时任务</li><li>cas7: 批处理逻辑执行后，将结果一一返回给队列的每个请求future</li><li>自旋1: MpscArrayQueue#offer()不提供返回余量，自行实现，则要自旋遍历加入队列</li></ul></blockquote><h1 id="真实代码"><a href="#真实代码" class="headerlink" title="真实代码"></a>真实代码</h1><p>待上传maven中央仓库</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>B+Tree简要理解</title>
      <link href="/2025/07/16/bplus-tree/"/>
      <url>/2025/07/16/bplus-tree/</url>
      
        <content type="html"><![CDATA[<p><code>B+Tree</code>是一种为磁盘等存取设备设计的平衡查找树，它实现了以<code>O(log n)</code>复杂度执行<code>查找、顺序读、插入和删除</code>操作。</p><p>与B-Tree主要区别：</p><blockquote><ol><li>非叶子节点不存数据，通过更低的树高度减少存取设备的IO次数</li></ol></blockquote><blockquote><ol start="2"><li>叶子节点有前后指针，通过双向链表实现高效的范围查找</li></ol></blockquote><p>实现B+Tree的核心思路：</p><ol><li>根据允许的节点最大空间（如mysql innodb默认16KB），算出每个节点的上下界(Lower&#x2F;Upper Bound)</li></ol><ul><li>根节点：关键字数在1至m-1个之间，子节点数在2-m个之间</li><li>非根非叶节点：关键字数在(m&#x2F;2)-1至m-1个之间，子节点数在ceil(m&#x2F;2)至个之间</li><li>叶节点：关键字数同<code>非根非叶节点</code>，无子节点<blockquote><p>m为非叶子节点的子节点数的最大值<br>如mysql innodb每页默认16KB，假设每行记录关键字4 byte，则一个非页子节点最多容纳 <code>16*1024/4=4096</code> 行记录关键字</p></blockquote></li></ul><ol start="2"><li>插入<blockquote><p>找到位置插入后，若节点关键字数超上界, 则</p><ol><li>取节点中间关键字拆成两个节点，把中间关键字插入父节点，插入位置由原父分割关键字位置决定(如原上级左则插右，反之则右左)</li><li>以父节点为中心检查是否超出上界，超出则递归执行第一、二步。</li></ol></blockquote></li><li>删除<blockquote><p>删除后，若当前节点关键字数低于下界，则</p><ol><li>向<code>大于下界</code>的<code>兄弟节点</code>借关键字(<code>原父分割关键字下沉，左或右兄弟节点关键字上升，直到借出目标节点完成关键字上升</code>)</li><li>无<code>大于下界</code>的<code>兄弟节点</code>，<code>合并一个相邻兄弟节点且原父分割关键字下沉</code>，以父节点为中心递归检查是否低于下界</li><li>节点调整后，要始终保证<code>页子节点的双向链表连续性</code>。</li></ol></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法&amp;数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AspectJ在Gradle的CTW案例</title>
      <link href="/2025/07/15/gradle-aspectj-ctw/"/>
      <url>/2025/07/15/gradle-aspectj-ctw/</url>
      
        <content type="html"><![CDATA[<p><code>AspectJ</code>的运行方式主要有三种：  </p><ol><li><strong>CTW(Compile Time Weaving)</strong><blockquote><p>编译时织入，依托 <code>构建工具(maven/gradle等)</code> 和 <code>AJC(AspectJ Compiler)</code>，在项目编译时修改字节码</p></blockquote></li><li><strong>LTW(Load Time Weaving)</strong><blockquote><p>加载时织入，依托 <code>Java Agent</code> 机制，在 <code>ClassLoader</code> 加载类时修改字节码</p></blockquote></li><li><strong>RTW(Run Time Weaving)</strong><blockquote><p>运行时织入，依托 <code>JDK代理</code>、<code>CGLIB</code> 等代理机制，在运行时动态修改字节码</p></blockquote></li></ol><hr><p>以下主要记录 <code>CTW</code> 方式下的组合：<strong>Gradle+AJC</strong> </p><h1 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h1><p>在项目 <code>settings.gradle</code> 中配置，统一管理该插件版本</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;io.freefair.settings.plugin-versions&#x27;</span> version <span class="string">&#x27;版本&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录 <code>build.gradle</code> 中配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.aspectj:aspectjtools:版本&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>项目/模块</code> 的 <code>build.gradle</code> 中配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&quot;io.freefair.aspectj.post-compile-weaving&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Idea配置"><a href="#Idea配置" class="headerlink" title="Idea配置"></a>Idea配置</h1><ol><li>安装Idea插件 <code>AspectJ</code></li><li>在Idea菜单<code>Project Structure</code> (即<code>项目结构</code>) &gt;<code>Facet</code> 中，添加 <code>AspectJ</code> 并选择对应模块</li></ol><hr><h1 id="注解式切面"><a href="#注解式切面" class="headerlink" title="注解式切面"></a>注解式切面</h1><p>与spring aop的使用方式类似</p><blockquote><p>如 <code>@Around</code>、<code>@Before</code>、<code>@After</code>、<code>@Pointcut</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code> 等</p></blockquote><p>主要不同点</p><ol><li><strong>切面顺序</strong></li></ol><ul><li>同一Aspect类有多个 <code>PointCut</code> 时，按定义的顺序  </li><li>不同Aspect类有同一连结点时，顺序随机，除非在Aspect类中声明<code>Declare Precedence</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aa;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@DeclarePrecedence(&quot;com.aa.AspectA,com.bb.AspectB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectA</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.bb;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@DeclarePrecedence(&quot;com.bb.AspectB,com.cc.AspectC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectB</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.cc;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AspectC</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>上述三个切面的执行顺序为：<code>A &gt; B &gt; C</code></p><ol start="2"><li><strong>切面作用域</strong><br>默认为<code>切面静态单例</code>，可选 <code>perthis</code> 和 <code>pertarget</code></li></ol><ul><li><strong>singleton</strong><blockquote><p>每个 <code>切面类</code> 有一个 <code>切面实例</code></p></blockquote></li></ul><blockquote><p>注意！此时在spring中配置@Bean时，不能用<code>new 切面类()</code>，而是 <code>Aspects.aspectOf(切面类.class)</code></p></blockquote><ul><li><strong>perthis</strong><blockquote><p>每个 <code>目标实例</code> 有一个 <code>切面实例</code>，<code>切面实例</code> 随着 <code>目标实例</code> 的 创建而创建、GC回收而回收</p></blockquote></li><li><strong>pertarget</strong><blockquote><p>每个 <code>目标类</code> 各有一个 <code>切面实例</code>，同一 <code>目标类</code> 的 <code>多个实例</code>共用该类的<code>切面实例</code></p></blockquote></li></ul><hr><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://docs.freefair.io/gradle-plugins/8.14/reference/#_aspectj" title="Freefair Gradle Plugin 8.14 Document">Freefair Gradle Plugin 8.14 Document</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包算法：01、完全</title>
      <link href="/2025/06/19/knapsack/"/>
      <url>/2025/06/19/knapsack/</url>
      
        <content type="html"><![CDATA[<p>待有空补充</p>]]></content>
      
      
      <categories>
          
          <category> 算法&amp;数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
